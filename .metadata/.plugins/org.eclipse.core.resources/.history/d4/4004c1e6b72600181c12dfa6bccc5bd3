/**
 * 
 */
package jp.co.lsij.p16590004.e_77.model.p_num;

import java.sql.Connection;
import java.util.List;

import jp.co.lsij.p16590004.common.Constants;
import jp.co.lsij.p16590004.common.DBDataSource;
import jp.co.lsij.p16590004.dao.DAOFactory;
import jp.co.lsij.p16590004.dao.DAOFactoryType;
import jp.co.lsij.p16590004.dao.TransactionManager;
import jp.co.lsij.p16590004.e_77.model.BeanDataType;
import jp.co.lsij.p16590004.e_77.model.FacadeType;
import jp.co.lsij.p16590004.e_77.model.IData;
import jp.co.lsij.p16590004.e_77.model.IDataList;
import jp.co.lsij.p16590004.e_77.model.IFacade;
import jp.co.lsij.p16590004.e_77.model.ProjNumAndSalesLock;
import jp.co.lsij.p16590004.e_77.model.SearchCondition;
import jp.co.lsij.p16590004.e_77.model.master.beans.PageBean;
import jp.co.lsij.p16590004.e_77.model.master.beans.SortBean;
import jp.co.lsij.p16590004.e_77.model.p_num.beans.AttachFileBean;
import jp.co.lsij.p16590004.e_77.model.p_num.beans.NotiUserBean;
import jp.co.lsij.p16590004.e_77.model.p_num.beans.ProjNumBean;
import jp.co.lsij.p16590004.e_77.model.p_num.dao.IProjNumDAO;
import jp.co.lsij.p16590004.e_77.model.p_num.dao.PostgresAttachFileWithProjNumDAO;
import jp.co.lsij.p16590004.e_77.model.p_num.dao.PostgresNotiUserWithProjNumDAO;
import jp.co.lsij.p16590004.e_77.model.sales.beans.SalesBean;
import jp.co.lsij.p16590004.e_77.model.sales.dao.PostgresSalesWithProjNumDAO;
import jp.co.lsij.p16590004.e_77.util.SalesBeanHelper;
import jp.co.lsij.p16590004.exception.PASMErrorType;
import jp.co.lsij.p16590004.exception.PASMException;
import jp.co.lsij.p16590004.exception.SubstituteRuntimeException;

/**
 * P番処理クラス
 * 
 * ・スレッドセーフでない
 * 
 * @version 1.0.0
 * @author dai
 *
 */
public class ProjNumFacade implements IFacade {

  /**
   * コンストラクタ
   */
  public ProjNumFacade() {
    // TODO 自動生成されたコンストラクター・スタブ
  }

  /**
   * P番取得処理
   * 
   * @param projNumDAO P番 DAO オブジェクト
   * @param destPage ページオブジェクト（total を本処理で格納する（その他は srcPage のコピー））
   * @param srcPage ページオブジェクト（offset, limit を設定する）
   * @param sortBean[] ソートオブジェクト配列
   * @param searchCondition 検索条件オブジェクト配列
   * @param isExcludeData ファイルデータ除外
   * @return P番データリストオブジェクト
   */
  protected IDataList query(IProjNumDAO projNumDAO, PageBean destPage, PageBean srcPage,
      SortBean[] sortBean, SearchCondition[] searchCondition, boolean isExcludeData) {
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));
    assert (null != destPage);
    assert ((null != srcPage) && (false != PageBean.isValidOffset(srcPage.getOffset())));
    assert ((null != srcPage) && (false != PageBean.isValidLimit(srcPage.getLimit())));
    assert ((null != sortBean) && (0 < sortBean.length));
    // assert ((null != searchCondition) && (0 < searchCondition.length));

    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    if (null == destPage) {
      throw new IllegalArgumentException();
    }
    if ((null == srcPage) || (false == PageBean.isValidOffset(srcPage.getOffset()))) {
      throw new IllegalArgumentException();
    }
    if ((null == srcPage) || (false == PageBean.isValidLimit(srcPage.getLimit()))) {
      throw new IllegalArgumentException();
    }
    if ((null == sortBean) || (0 >= sortBean.length)) {
      throw new IllegalArgumentException();
    }
    // if ((null == searchCondition) || (0 >= searchCondition.length)) {
    // throw new IllegalArgumentException();
    // }
    long lTotal = 0;
    IDataList dataList = null;

    if ((null == searchCondition) || (0 >= searchCondition.length)) {
      dataList = projNumDAO.select(sortBean, srcPage.getLimit(), srcPage.getOffset());
      lTotal = projNumDAO.getNumberOfProjNum();
    } else {
      dataList =
          projNumDAO.select(searchCondition, sortBean, srcPage.getLimit(), srcPage.getOffset());
      lTotal = projNumDAO.getNumberOfProjNum(searchCondition);
    }
    int nSize = dataList.size();
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      IData iData = dataList.get(nCnt);
      ProjNumBean projNumBean = null;

      if (iData instanceof ProjNumBean) {
        projNumBean = (ProjNumBean) iData;
        // PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
      IDataList attachFileList = null;
      attachFileList = PostgresAttachFileWithProjNumDAO
          .selectWithProjNumID(projNumDAO.getConnection(), projNumBean.getId(), isExcludeData);
      IDataList notiUserList = null;
      notiUserList = PostgresNotiUserWithProjNumDAO.selectWithProjNumID(projNumDAO.getConnection(),
          projNumBean.getId());

      projNumBean.setAttachFileBeanList(attachFileList);
      projNumBean.setNotiUserBeanList(notiUserList);
      // 必要？
      dataList.set(nCnt, projNumBean);
    }
    destPage.setOffset(srcPage.getOffset());
    destPage.setLimit(srcPage.getLimit());
    destPage.setTotal(lTotal);

    return dataList;
  }

  /**
   * P番取得処理
   * 
   * @param lID P番ID
   * @param isExcludeData ファイルデータ除外
   * @param projNumDAO P番 DAO オブジェクト
   * @return P番データリストオブジェクト
   */
  protected IDataList query(long lID, boolean isExcludeData, IProjNumDAO projNumDAO) {
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    IDataList dataList = null;

    dataList = projNumDAO.select(lID);
    int nSize = dataList.size();
    // #if 1 new （参照前にデータが削除されている場合の対応）
    if (0 >= nSize) {
      return dataList;
    }
    // #endif
    if (1 != nSize) {
      assert (false);
      throw new IllegalStateException();
    }
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      IData iData = dataList.get(nCnt);
      ProjNumBean projNumBean = null;

      if (iData instanceof ProjNumBean) {
        projNumBean = (ProjNumBean) iData;
        // PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
      IDataList attachFileList = null;
      attachFileList = PostgresAttachFileWithProjNumDAO
          .selectWithProjNumID(projNumDAO.getConnection(), projNumBean.getId(), isExcludeData);
      IDataList notiUserList = null;
      notiUserList = PostgresNotiUserWithProjNumDAO.selectWithProjNumID(projNumDAO.getConnection(),
          projNumBean.getId());

      projNumBean.setAttachFileBeanList(attachFileList);
      projNumBean.setNotiUserBeanList(notiUserList);
      // 必要？
      dataList.set(nCnt, projNumBean);
    }

    return dataList;
  }

  /**
   * P番取得処理
   * 
   * @param strProjNum P番
   * @param isExcludeData ファイルデータ除外
   * @param projNumDAO P番 DAO オブジェクト
   * @return P番データリストオブジェクト
   */
  protected IDataList queryByProjNum(String strProjNum, boolean isExcludeData,
      IProjNumDAO projNumDAO) {
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    IDataList dataList = null;

    dataList = projNumDAO.selectWithProjNum(strProjNum);
    int nSize = dataList.size();
    // #if 1 new （参照前にデータが削除されている場合の対応）
    if (0 >= nSize) {
      return dataList;
    }
    // #endif
    if (1 != nSize) {
      assert (false);
      throw new IllegalStateException();
    }
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      IData iData = dataList.get(nCnt);
      ProjNumBean projNumBean = null;

      if (iData instanceof ProjNumBean) {
        projNumBean = (ProjNumBean) iData;
        // PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
      IDataList attachFileList = null;
      attachFileList = PostgresAttachFileWithProjNumDAO
          .selectWithProjNumID(projNumDAO.getConnection(), projNumBean.getId(), isExcludeData);
      IDataList notiUserList = null;
      notiUserList = PostgresNotiUserWithProjNumDAO.selectWithProjNumID(projNumDAO.getConnection(),
          projNumBean.getId());

      projNumBean.setAttachFileBeanList(attachFileList);
      projNumBean.setNotiUserBeanList(notiUserList);
      // 必要？
      dataList.set(nCnt, projNumBean);
    }

    return dataList;
  }

  /**
   * P番追加処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 作成者、添付ファイル、通知ユーザー、工数単価のみ使用）
   * @param isAddedSales 販売追加フラグ
   * @param projNumDAO P番 DAO オブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  protected int add(ProjNumBean projNumBean, boolean isAddedSales, IProjNumDAO projNumDAO)
      throws PASMException {
    assert (null != projNumBean);
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if (null == projNumBean) {
      throw new IllegalArgumentException();
    }
    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    if (false != projNumDAO.isAlreadyExistProjNum(projNumBean.getProjNum())) {
      // 既にP番が存在している
      // 例外か戻り値か？
      throw new PASMException(PASMErrorType.NOT_UNIQUE, "P番が重複しています");// 例外か戻り値か？
      // return;
    }
    int nLine = -1;

    nLine = projNumDAO.insert(projNumBean);
    if (false == ProjNumBean.isValidID(projNumBean.getId())) {
      assert (false);
      throw new IllegalStateException();
    }

    /* nLine = */PostgresAttachFileWithProjNumDAO.deleteWithProjNumID(projNumDAO.getConnection(),
        projNumBean.getId());
    /* nLine = */PostgresNotiUserWithProjNumDAO.deleteWithProjNumID(projNumDAO.getConnection(),
        projNumBean.getId());

    int nSize = projNumBean.getAttachFileBeanListSize();
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      AttachFileBean attachFileBean = null;
      IData iData = projNumBean.getAttachFileBean(nCnt);

      if (iData instanceof AttachFileBean) {
        attachFileBean = (AttachFileBean) iData;
        attachFileBean.setProjNumTblId(projNumBean.getId());
        PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
    }
    nSize = projNumBean.getNotiUserBeanListSize();
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      NotiUserBean notiUserBean = null;
      IData iData = projNumBean.getNotiUserBean(nCnt);

      if (iData instanceof NotiUserBean) {
        notiUserBean = (NotiUserBean) iData;
        notiUserBean.setProjNumTblId(projNumBean.getId());
        PostgresNotiUserWithProjNumDAO.insert(projNumDAO.getConnection(), notiUserBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
    }
    if (false != isAddedSales) {
      SalesBean salesBean = SalesBeanHelper.projNumBeanToSalesBean(projNumBean);
      PostgresSalesWithProjNumDAO.insert(projNumDAO.getConnection(), salesBean);// int
    }

    return nLine;
  }

  /**
   * P番変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 更新者、添付ファイル（新規追加分のみ）、通知ユーザー、工数単価、プロジェクト終了フラグのみ使用）
   * @param deleteAttachFileIDList 削除する添付ファイルのIDリスト
   * @param projNumDAO P番 DAO オブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // ※projNumBean 内の添付ファイル設定は、更新で新規に追加される分のみ設定される
  // よって、更新で削除になる分は、projNumBean 以外の別データ（List<long>）で渡す
  // 通知ユーザーは、既存の通知ユーザーを全て削除し、projNumBean 内の内容を新規に追加する
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modify(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
      IProjNumDAO projNumDAO) throws PASMException {
    // #else
    // protected int modify(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
    // IProjNumDAO projNumDAO) {
    // #endif
    assert (null != projNumBean);
    assert (null != deleteAttachFileIDList);
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if (null == projNumBean) {
      throw new IllegalArgumentException();
    }
    if (null == deleteAttachFileIDList) {
      throw new IllegalArgumentException();
    }
    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    int nLine = -1;

    // #if 1 new （修正前にデータが削除されている場合の対応）
    IDataList iDataList = projNumDAO.select(projNumBean.getId());
    if (null == iDataList) {
      assert (false);
      throw new IllegalStateException();
    }
    if (0 >= iDataList.size()) {
      throw new PASMException(PASMErrorType.NOT_FOUND, "指定のＰ番が見つかりません");
    }
    // #endif
    nLine = projNumDAO.update(projNumBean.getId(), projNumBean);
    /* nLine = */PostgresNotiUserWithProjNumDAO.deleteWithProjNumID(projNumDAO.getConnection(),
        projNumBean.getId());
    for (Long lAttachFileID : deleteAttachFileIDList) {
      /* nLine = */PostgresAttachFileWithProjNumDAO.delete(projNumDAO.getConnection(),
          lAttachFileID.longValue());
    }

    int nSize = projNumBean.getAttachFileBeanListSize();
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      AttachFileBean attachFileBean = null;
      IData iData = projNumBean.getAttachFileBean(nCnt);

      if (iData instanceof AttachFileBean) {
        attachFileBean = (AttachFileBean) iData;
        attachFileBean.setProjNumTblId(projNumBean.getId());
        PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
    }
    nSize = projNumBean.getNotiUserBeanListSize();
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      NotiUserBean notiUserBean = null;
      IData iData = projNumBean.getNotiUserBean(nCnt);

      if (iData instanceof NotiUserBean) {
        notiUserBean = (NotiUserBean) iData;
        notiUserBean.setProjNumTblId(projNumBean.getId());
        PostgresNotiUserWithProjNumDAO.insert(projNumDAO.getConnection(), notiUserBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
    }
    return nLine;
  }

  // ---ここから Phase 2 追加分---
  /**
   * 指定P番の仕入れ総額変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、仕入れ総額のみ使用）
   * @param isNew 新仕入れ総額フラグ
   * @param projNumDAO P番 DAO オブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyPurchaseAmount(ProjNumBean projNumBean, boolean isNew, IProjNumDAO projNumDAO)
      throws PASMException {
    // #else
    // protected int modifyPurchaseAmount(ProjNumBean projNumBean, boolean isNew,
    // IProjNumDAO projNumDAO) {
    // #endif
    assert (null != projNumBean);
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if (null == projNumBean) {
      throw new IllegalArgumentException();
    }
    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    int nLine = -1;

    // #if 1 new （修正前にデータが削除されている場合の対応）
    IDataList iDataList = projNumDAO.selectWithProjNum(projNumBean.getProjNum());
    // IDataList iDataList = projNumDAO.select(projNumBean.getId());
    if (null == iDataList) {
      assert (false);
      throw new IllegalStateException();
    }
    if (0 >= iDataList.size()) {
      throw new PASMException(PASMErrorType.NOT_FOUND, "指定のＰ番が見つかりません");
    }
    // #endif
    // selectWithProjNum() の場合用（ここから）
    IData iData = iDataList.get(0);

    if (iData instanceof ProjNumBean) {
      projNumBean.setId(((ProjNumBean) iData).getId());
      // PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
    } else {
      assert (false);
      throw new IllegalStateException();
    }
    // selectWithProjNum() の場合用（ここまで）
    long lPurchaseAmount =
        (false == isNew) ? projNumBean.getPrePurchaseAmount() : projNumBean.getNewPurchaseAmount();
    nLine = projNumDAO.updatePurchaseAmount(projNumBean.getId(), lPurchaseAmount, isNew);

    return nLine;
  }

  /**
   * 指定P番の総作業時間変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、総作業時間のみ使用）
   * @param projNumDAO P番 DAO オブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyWorkingTime(ProjNumBean projNumBean, IProjNumDAO projNumDAO)
      throws PASMException {
    // #else
    // protected int modifyWorkingTime(ProjNumBean projNumBean,
    // IProjNumDAO projNumDAO) {
    // #endif
    assert (null != projNumBean);
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if (null == projNumBean) {
      throw new IllegalArgumentException();
    }
    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    int nLine = -1;

    // #if 1 new （修正前にデータが削除されている場合の対応）
    IDataList iDataList = projNumDAO.select(projNumBean.getId());
    if (null == iDataList) {
      assert (false);
      throw new IllegalStateException();
    }
    if (0 >= iDataList.size()) {
      throw new PASMException(PASMErrorType.NOT_FOUND, "指定のＰ番が見つかりません");
    }
    // #endif
    nLine = projNumDAO.updateWorkingTime(projNumBean.getId(), projNumBean.getTotalWorkingTime());

    return nLine;
  }
  // ---ここまで Phase 2 追加分---

  /**
   * P番削除処理
   * 
   * @param lID 削除するP番ID
   * @param projNumDAO P番 DAO オブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1//Phase 2
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  protected int delete(long lID, IProjNumDAO projNumDAO) throws PASMException {
    // #else//Phase 1
    // protected int delete(long lID, IProjNumDAO projNumDAO) {
    // #endif
    assert ((null != projNumDAO) && (false != projNumDAO.isConnected()));

    if ((null == projNumDAO) || (false == projNumDAO.isConnected())) {
      throw new IllegalArgumentException();
    }
    int nLine = -1;

    // #if 1 new （削除前にデータが削除されている場合の対応）
    IDataList iDataList = projNumDAO.select(lID);
    if (null == iDataList) {
      assert (false);
      throw new IllegalStateException();
    }
    if (0 >= iDataList.size()) {
      // throw new PASMException(PASMErrorType.NOT_FOUND, "指定のＰ番が見つかりません");
      return 0;// 削除済みは特に例外としない
    }
    // #endif

    // ---ここから Phase 2 追加分---
    int nSize = iDataList.size();
    for (int nCnt = 0; nCnt < nSize; nCnt++) {
      IData iData = iDataList.get(nCnt);
      ProjNumBean projNumBean = null;

      if (iData instanceof ProjNumBean) {
        projNumBean = (ProjNumBean) iData;
        // PostgresAttachFileWithProjNumDAO.insert(projNumDAO.getConnection(), attachFileBean);
      } else {
        assert (false);
        throw new IllegalStateException();
      }
      if ((0 != projNumBean.getPrePurchaseAmount()) || (0 != projNumBean.getNewPurchaseAmount())) {
        throw new PASMException(PASMErrorType.INVALID, "仕入れ総額が設定されています");
      }
      if ((null != projNumBean.getTotalWorkingTime())
          && (false == projNumBean.getTotalWorkingTime().isEmpty())) {
        long[] hourMinSec = projNumBean.getTotalWorkingTimeWithLongArray();

        if ((0 != hourMinSec[0]) || (0 != hourMinSec[1]) || (0 != hourMinSec[2])) {
          // 総作業時間が設定されている場合
          throw new PASMException(PASMErrorType.INVALID, "総作業時間が設定されています");
        }
      }
    }
    // ---ここまで Phase 2 追加分---

    /* nLine = */PostgresAttachFileWithProjNumDAO.deleteWithProjNumID(projNumDAO.getConnection(),
        lID);
    /* nLine = */PostgresNotiUserWithProjNumDAO.deleteWithProjNumID(projNumDAO.getConnection(),
        lID);

    nLine = projNumDAO.delete(lID);

    return nLine;
  }

  /**
   * （JTA 使用しない版）P番取得処理
   * 
   * @param dbDataSource DBデータソースオブジェクト
   * @param destPage ページオブジェクト（total を本処理で格納する（その他は srcPage のコピー））
   * @param srcPage ページオブジェクト（offset, limit を設定する）
   * @param sortBean[] ソートオブジェクト配列
   * @param searchCondition 検索条件オブジェクト配列
   * @param isExcludeData ファイルデータ除外
   * @return P番データリストオブジェクト
   */
  protected IDataList queryWithoutJTA(DBDataSource dbDataSource, PageBean destPage,
      PageBean srcPage, SortBean[] sortBean, SearchCondition[] searchCondition,
      boolean isExcludeData) {
    assert (null != destPage);
    assert ((null != srcPage) && (false != PageBean.isValidOffset(srcPage.getOffset())));
    assert ((null != srcPage) && (false != PageBean.isValidLimit(srcPage.getLimit())));
    assert ((null != sortBean) && (0 < sortBean.length));
    // assert ((null != searchCondition) && (0 < searchCondition.length));

    if (null == destPage) {
      throw new IllegalArgumentException();
    }
    if ((null == srcPage) || (false == PageBean.isValidOffset(srcPage.getOffset()))) {
      throw new IllegalArgumentException();
    }
    if ((null == srcPage) || (false == PageBean.isValidLimit(srcPage.getLimit()))) {
      throw new IllegalArgumentException();
    }
    if ((null == sortBean) || (0 >= sortBean.length)) {
      throw new IllegalArgumentException();
    }
    // if ((null == searchCondition) || (0 >= searchCondition.length)) {
    // throw new IllegalArgumentException();
    // }
    // DAOインスタンスの生成
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    IDataList dataList = null;

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      dataList = query(projNumDAO, destPage, srcPage, sortBean, searchCondition, isExcludeData);
      // コミット処理
      projNumDAO.commit();
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return dataList;
  }

  /**
   * （JTA 使用する版）P番取得処理
   * 
   * @param dbDataSource DBデータソースオブジェクト
   * @param destPage ページオブジェクト（total を本処理で格納する（その他は srcPage のコピー））
   * @param srcPage ページオブジェクト（offset, limit を設定する）
   * @param sortBean ソートオブジェクト配列
   * @param searchCondition 検索条件オブジェクト配列
   * @param isExcludeData ファイルデータ除外
   * @return P番データリストオブジェクト
   */
  protected IDataList queryWithJTA(DBDataSource dbDataSource, PageBean destPage, PageBean srcPage,
      SortBean[] sortBean, SearchCondition[] searchCondition, boolean isExcludeData) {
    assert (null != destPage);
    assert ((null != srcPage) && (false != PageBean.isValidOffset(srcPage.getOffset())));
    assert ((null != srcPage) && (false != PageBean.isValidLimit(srcPage.getLimit())));
    assert ((null != sortBean) && (0 < sortBean.length));
    // assert ((null != searchCondition) && (0 < searchCondition.length));

    if (null == destPage) {
      throw new IllegalArgumentException();
    }
    if ((null == srcPage) || (false == PageBean.isValidOffset(srcPage.getOffset()))) {
      throw new IllegalArgumentException();
    }
    if ((null == srcPage) || (false == PageBean.isValidLimit(srcPage.getLimit()))) {
      throw new IllegalArgumentException();
    }
    if ((null == sortBean) || (0 >= sortBean.length)) {
      throw new IllegalArgumentException();
    }
    // if ((null == searchCondition) || (0 >= searchCondition.length)) {
    // throw new IllegalArgumentException();
    // }
    // DAOインスタンスの生成
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    IDataList dataList = null;

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      dataList = query(projNumDAO, destPage, srcPage, sortBean, searchCondition, isExcludeData);
      // コミット処理
      tm.commit();
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return dataList;
  }

  /**
   * （JTA 使用しない版）P番取得処理
   * 
   * @param lID P番ID
   * @param isExcludeData ファイルデータ除外
   * @param dbDataSource DBデータソースオブジェクト
   * @return P番データリストオブジェクト
   */
  protected IDataList queryWithoutJTA(long lID, boolean isExcludeData, DBDataSource dbDataSource) {
    // DAOインスタンスの生成
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    IDataList dataList = null;

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      dataList = query(lID, isExcludeData, projNumDAO);
      // コミット処理
      projNumDAO.commit();
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return dataList;
  }

  /**
   * （JTA 使用する版）P番取得処理
   * 
   * @param lID P番ID
   * @param isExcludeData ファイルデータ除外
   * @param dbDataSource DBデータソースオブジェクト
   * @return P番データリストオブジェクト
   */
  protected IDataList queryWithJTA(long lID, boolean isExcludeData, DBDataSource dbDataSource) {
    // DAOインスタンスの生成
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    IDataList dataList = null;

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      dataList = query(lID, isExcludeData, projNumDAO);
      // コミット処理
      tm.commit();
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return dataList;
  }

  /**
   * （JTA 使用しない版）P番取得処理
   * 
   * @param strProjNum P番
   * @param isExcludeData ファイルデータ除外
   * @param dbDataSource DBデータソースオブジェクト
   * @return P番データリストオブジェクト
   */
  protected IDataList queryByProjNumWithoutJTA(String strProjNum, boolean isExcludeData,
      DBDataSource dbDataSource) {
    // DAOインスタンスの生成
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    IDataList dataList = null;

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      dataList = queryByProjNum(strProjNum, isExcludeData, projNumDAO);
      // コミット処理
      projNumDAO.commit();
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return dataList;
  }

  /**
   * （JTA 使用する版）P番取得処理
   * 
   * @param strProjNum P番
   * @param isExcludeData ファイルデータ除外
   * @param dbDataSource DBデータソースオブジェクト
   * @return P番データリストオブジェクト
   */
  protected IDataList queryByProjNumWithJTA(String strProjNum, boolean isExcludeData,
      DBDataSource dbDataSource) {
    // DAOインスタンスの生成
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    IDataList dataList = null;

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      dataList = queryByProjNum(strProjNum, isExcludeData, projNumDAO);
      // コミット処理
      tm.commit();
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return dataList;
  }

  /**
   * （JTA 使用しない版）P番追加処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 作成者、添付ファイル、通知ユーザー、工数単価のみ使用）
   * @param isAddedSales 販売追加フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  protected int addWithoutJTA(ProjNumBean projNumBean, boolean isAddedSales,
      DBDataSource dbDataSource) throws PASMException {
    // DAOインスタンスの生成
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = add(projNumBean, isAddedSales, projNumDAO);
      // コミット処理
      projNumDAO.commit();
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用する版）P番追加処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 作成者、添付ファイル、通知ユーザー、工数単価のみ使用）
   * @param isAddedSales 販売追加フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  protected int addWithJTA(ProjNumBean projNumBean, boolean isAddedSales, DBDataSource dbDataSource)
      throws PASMException {
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = add(projNumBean, isAddedSales, projNumDAO);
      // コミット処理
      tm.commit();
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用しない版）P番変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 更新者、添付ファイル（新規追加分のみ）、通知ユーザー、工数単価、プロジェクト終了フラグのみ使用）
   * @param deleteAttachFileIDList 削除する添付ファイルのIDリスト
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // ※projNumBean 内の添付ファイル設定は、更新で新規に追加される分のみ設定される
  // よって、更新で削除になる分は、projNumBean 以外の別データ（List<long>）で渡す
  // 通知ユーザーは、既存の通知ユーザーを全て削除し、projNumBean 内の内容を新規に追加する
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyWithoutJTA(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
      DBDataSource dbDataSource) throws PASMException {
    // #else
    // protected int modifyWithoutJTA(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
    // DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = modify(projNumBean, deleteAttachFileIDList, projNumDAO);
      // コミット処理
      projNumDAO.commit();
      // #if 1 new （修正前にデータが削除されている場合の対応）
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用する版）P番変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 更新者、添付ファイル（新規追加分のみ）、通知ユーザー、工数単価、プロジェクト終了フラグのみ使用）
   * @param deleteAttachFileIDList 削除する添付ファイルのIDリスト
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // ※projNumBean 内の添付ファイル設定は、更新で新規に追加される分のみ設定される
  // よって、更新で削除になる分は、projNumBean 以外の別データ（List<long>）で渡す
  // 通知ユーザーは、既存の通知ユーザーを全て削除し、projNumBean 内の内容を新規に追加する
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyWithJTA(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
      DBDataSource dbDataSource) throws PASMException {
    // #else
    // protected int modifyWithJTA(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
    // DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = modify(projNumBean, deleteAttachFileIDList, projNumDAO);
      // コミット処理
      tm.commit();
      // #if 1 new （修正前にデータが削除されている場合の対応）
    } catch (PASMException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  // ---ここから Phase 2 追加分---
  /**
   * （JTA 使用しない版）指定P番の仕入れ総額変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、仕入れ総額のみ使用）
   * @param isNew 新仕入れ総額フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyPurchaseAmountWithoutJTA(ProjNumBean projNumBean, boolean isNew,
      DBDataSource dbDataSource) throws PASMException {
    // #else
    // protected int modifyPurchaseAmountWithoutJTA(ProjNumBean projNumBean, boolean isNew,
    // DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = modifyPurchaseAmount(projNumBean, isNew, projNumDAO);
      // コミット処理
      projNumDAO.commit();
      // #if 1 new （修正前にデータが削除されている場合の対応）
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用する版）指定P番の仕入れ総額変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、仕入れ総額のみ使用）
   * @param isNew 新仕入れ総額フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyPurchaseAmountWithJTA(ProjNumBean projNumBean, boolean isNew,
      DBDataSource dbDataSource) throws PASMException {
    // #else
    // protected int modifyPurchaseAmountWithJTA(ProjNumBean projNumBean, isNew,
    // DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = modifyPurchaseAmount(projNumBean, isNew, projNumDAO);
      // コミット処理
      tm.commit();
      // #if 1 new （修正前にデータが削除されている場合の対応）
    } catch (PASMException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用しない版）指定P番の総作業時間変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、総作業時間のみ使用）
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyWorkingTimeWithoutJTA(ProjNumBean projNumBean, DBDataSource dbDataSource)
      throws PASMException {
    // #else
    // protected int modifyWorkingTimeWithoutJTA(ProjNumBean projNumBean,
    // DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = modifyWorkingTime(projNumBean, projNumDAO);
      // コミット処理
      projNumDAO.commit();
      // #if 1 new （修正前にデータが削除されている場合の対応）
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用する版）指定P番の総作業時間変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、総作業時間のみ使用）
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  protected int modifyWorkingTimeWithJTA(ProjNumBean projNumBean, DBDataSource dbDataSource)
      throws PASMException {
    // #else
    // protected int modifyWorkingTimeWithJTA(ProjNumBean projNumBean,
    // DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = modifyWorkingTime(projNumBean, projNumDAO);
      // コミット処理
      tm.commit();
      // #if 1 new （修正前にデータが削除されている場合の対応）
    } catch (PASMException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }
  // ---ここまで Phase 2 追加分---

  /**
   * （JTA 使用しない版）P番削除処理
   * 
   * @param lID 削除するP番ID
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1//Phase 2
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  protected int deleteWithoutJTA(long lID, DBDataSource dbDataSource) throws PASMException {
    // #else//Phase 1
    // protected int deleteWithoutJTA(long lID, DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = delete(lID, projNumDAO);
      // コミット処理
      projNumDAO.commit();
      // #if 1 Phase 2
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用する版）P番削除処理
   * 
   * @param lID 削除するP番ID
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1//Phase 2
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  protected int deleteWithJTA(long lID, DBDataSource dbDataSource) throws PASMException {
    // #else//Phase 1
    // protected int deleteWithJTA(long lID, DBDataSource dbDataSource) {
    // #endif
    int nLine = -1;
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      nLine = delete(lID, projNumDAO);
      // コミット処理
      tm.commit();
      // #if 1//Phase 2
    } catch (PASMException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return nLine;
  }

  /**
   * （JTA 使用しない版）P番削除処理
   * 
   * @param lIDs 削除するP番 ID 配列
   * @param dbDataSource DBデータソースオブジェクト
   * @return 配列 (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1//Phase 2
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  protected int[] deleteWithoutJTA(long[] lIDs, DBDataSource dbDataSource) throws PASMException {
    // #else//Phase 1
    // protected int[] deleteWithoutJTA(long[] lIDs, DBDataSource dbDataSource) {
    // #endif
    int[] arryLine = null;
    arryLine = new int[lIDs.length];
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    try {
      // トランザクション開始
      projNumDAO.begin(Connection.TRANSACTION_SERIALIZABLE);
      // projNumDAO.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      int nCnt = 0;
      for (long lID : lIDs) {
        arryLine[nCnt] = delete(lID, projNumDAO);
        nCnt++;
      }
      // コミット処理
      projNumDAO.commit();
      // #if 1 Phase 2
    } catch (PASMException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        projNumDAO.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return arryLine;
  }

  /**
   * （JTA 使用する版）P番削除処理
   * 
   * @param lIDs 削除するP番 ID 配列
   * @param dbDataSource DBデータソースオブジェクト
   * @return 配列 (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1//Phase 2
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  protected int[] deleteWithJTA(long[] lIDs, DBDataSource dbDataSource) throws PASMException {
    // #else//Phase 1
    // protected int[] deleteWithJTA(long[] lIDs, DBDataSource dbDataSource) {
    // #endif
    int[] arryLine = null;
    arryLine = new int[lIDs.length];
    DAOFactory dao = DAOFactory.getDAOFactory(DAOFactoryType.POSTGRES);
    IProjNumDAO projNumDAO = dao.getProjNumDAO(dbDataSource);

    // トランザクション・リソースの取得
    TransactionManager tm = new TransactionManager();

    try {
      // トランザクションの開始
      tm.begin();
    } catch (SubstituteRuntimeException err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    try {
      int nCnt = 0;
      for (long lID : lIDs) {
        arryLine[nCnt] = delete(lID, projNumDAO);
        nCnt++;
      }
      // コミット処理
      tm.commit();
      // #if 1//Phase 2
    } catch (PASMException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
      // #endif
    } catch (SubstituteRuntimeException err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    } catch (Exception err) {
      try {
        // ロールバック処理
        tm.rollback();
      } catch (Exception err_2) {
        assert (false);
      }
      try {
        projNumDAO.close();
      } catch (Exception err_2) {
        assert (false);
      }
      throw err;
    }
    // 例外時と正常時の処理を変えたいので、finally で処理しない
    // コネクションのクローズ
    projNumDAO.close();

    return arryLine;
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#getFacadeType()
   */
  @Override
  public FacadeType getFacadeType() {
    // TODO 自動生成されたメソッド・スタブ
    return FacadeType.PROJ_NUM_FACADE;
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#query(jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  public IDataList query(DBDataSource dbDataSource) {
    // TODO 自動生成されたメソッド・スタブ
    throw new UnsupportedOperationException("未サポート");
    // return null;
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#query(jp.co.lsij.p16590004.common.DBDataSource,
   * jp.co.lsij.p16590004.e_77.model.master.beans.SortBean[])
   */
  @Override
  public IDataList query(DBDataSource dbDataSource, SortBean[] sortBean) {
    // TODO 自動生成されたメソッド・スタブ
    throw new UnsupportedOperationException("未サポート");
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#query(jp.co.lsij.p16590004.common.DBDataSource,
   * jp.co.lsij.p16590004.e_77.model.master.beans.PageBean,
   * jp.co.lsij.p16590004.e_77.model.master.beans.PageBean)
   */
  @Override
  public IDataList query(DBDataSource dbDataSource, PageBean destPage, PageBean srcPage) {
    // TODO 自動生成されたメソッド・スタブ
    throw new UnsupportedOperationException("未サポート");
    // return null;
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#query(jp.co.lsij.p16590004.common.DBDataSource,
   * jp.co.lsij.p16590004.e_77.model.master.beans.PageBean,
   * jp.co.lsij.p16590004.e_77.model.master.beans.PageBean,
   * jp.co.lsij.p16590004.e_77.model.master.beans.SortBean[])
   */
  @Override
  public IDataList query(DBDataSource dbDataSource, PageBean destPage, PageBean srcPage,
      SortBean[] sortBean) {
    // TODO 自動生成されたメソッド・スタブ
    // #if 1//new 同期処理追加
    // 同期処理は入れない
    // #endif
    if (false == Constants.USE_JTA_MODE) {
      return queryWithoutJTA(dbDataSource, destPage, srcPage, sortBean, null, true);
    }
    return queryWithJTA(dbDataSource, destPage, srcPage, sortBean, null, true);
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#query(jp.co.lsij.p16590004.common.DBDataSource,
   * jp.co.lsij.p16590004.e_77.model.master.beans.PageBean,
   * jp.co.lsij.p16590004.e_77.model.master.beans.PageBean,
   * jp.co.lsij.p16590004.e_77.model.master.beans.SortBean[],
   * jp.co.lsij.p16590004.e_77.model.SearchCondition[])
   */
  @Override
  public IDataList query(DBDataSource dbDataSource, PageBean destPage, PageBean srcPage,
      SortBean[] sortBean, SearchCondition[] searchCondition) {
    // TODO 自動生成されたメソッド・スタブ
    // #if 1//new 同期処理追加
    // 同期処理は入れない
    // #endif
    if (false == Constants.USE_JTA_MODE) {
      return queryWithoutJTA(dbDataSource, destPage, srcPage, sortBean, searchCondition, true);
    }
    return queryWithJTA(dbDataSource, destPage, srcPage, sortBean, searchCondition, true);
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#query(long,
   * jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  // #if 1 new （参照前にデータが削除されている場合の対応）
  public IData query(long lID, DBDataSource dbDataSource) throws PASMException {
    // #else//org
    // public IData query(long lID, DBDataSource dbDataSource) {
    // #endif
    // TODO 自動生成されたメソッド・スタブ
    IDataList iDataList = null;

    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        iDataList = queryWithoutJTA(lID, false, dbDataSource);
      } else {
        iDataList = queryWithJTA(lID, false, dbDataSource);
      }
    }
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // iDataList = queryWithoutJTA(lID, false, dbDataSource);
    // } else {
    // iDataList = queryWithJTA(lID, false, dbDataSource);
    // }
    // #endif
    int nSize = iDataList.size();
    // #if 1 new （参照前にデータが削除されている場合の対応）
    if (0 >= nSize) {
      throw new PASMException(PASMErrorType.NOT_FOUND, "指定のＰ番が見つかりません");
    }
    // #endif
    if (1 != nSize) {
      assert (false);
      throw new IllegalStateException();
    }
    return iDataList.get(0).deepCopy();
  }

  /**
   * データリストを取得
   * 
   * @param strProjNum 取得するP番
   * @param dbDataSource データソースオブジェクト
   * @return データオブジェクト
   */
  public IData queryByProjNum(String strProjNum, DBDataSource dbDataSource) throws PASMException {
    IDataList iDataList = null;

    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        iDataList = queryByProjNumWithoutJTA(strProjNum, true, dbDataSource);
      } else {
        iDataList = queryByProjNumWithJTA(strProjNum, true, dbDataSource);
      }
    }
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // iDataList = queryByProjNumWithoutJTA(strProjNum, true, dbDataSource);
    // } else {
    // iDataList = queryByProjNumWithJTA(strProjNum, true, dbDataSource);
    // }
    // #endif
    int nSize = iDataList.size();
    // #if 1 new （参照前にデータが削除されている場合の対応）
    if (0 >= nSize) {
      throw new PASMException(PASMErrorType.NOT_FOUND, "指定のＰ番が見つかりません");
    }
    // #endif
    if (1 != nSize) {
      assert (false);
      throw new IllegalStateException();
    }
    return iDataList.get(0).deepCopy();
  }

  /**
   * P番データ追加処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 作成者、添付ファイル、通知ユーザー、工数単価のみ使用）
   * @param isAddedSales 販売追加フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  public int add(ProjNumBean projNumBean, boolean isAddedSales, DBDataSource dbDataSource)
      throws PASMException {
    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    int nRet = -1;
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        nRet = addWithoutJTA(projNumBean, isAddedSales, dbDataSource);
      } else {
        nRet = addWithJTA(projNumBean, isAddedSales, dbDataSource);
      }
    }
    return nRet;
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // return addWithoutJTA(projNumBean, isAddedSales, dbDataSource);
    // }
    // return addWithJTA(projNumBean, isAddedSales, dbDataSource);
    // #endif
  }

  /**
   * P番データ追加処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 作成者、添付ファイル、通知ユーザー、工数単価のみ使用）
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // public int add(ProjNumBean projNumBean, DBDataSource dbDataSource) throws PASMException {
  // if (false == Constants.USE_JTA_MODE) {
  // return addWithoutJTA(projNumBean, dbDataSource);
  // }
  // return addWithJTA(projNumBean, dbDataSource);
  // }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#add(jp.co.lsij.p16590004.e_77.model.IData,
   * jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  public int add(IData iData, DBDataSource dbDataSource) throws PASMException {
    // TODO 自動生成されたメソッド・スタブ
    assert (null != iData);

    if (null == iData) {
      throw new IllegalArgumentException();
    }
    if (BeanDataType.PROJ_NUM_DATA != iData.getDataType()) {
      throw new IllegalArgumentException();
    }
    ProjNumBean projNumBean = null;
    if (iData instanceof ProjNumBean) {
      projNumBean = (ProjNumBean) iData;
    } else {
      assert (false);
      throw new IllegalStateException();
    }

    return add(projNumBean, false, dbDataSource);
  }

  /**
   * P番変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 更新者、添付ファイル（新規追加分のみ）、通知ユーザー、工数単価、プロジェクト終了フラグのみ使用）
   * @param deleteAttachFileIDList 削除する添付ファイルのIDリスト
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // ※projNumBean 内の添付ファイル設定は、更新で新規に追加される分のみ設定される
  // よって、更新で削除になる分は、projNumBean 以外の別データ（List<long>）で渡す
  // 通知ユーザーは、既存の通知ユーザーを全て削除し、projNumBean 内の内容を新規に追加する
  // #if 1 new （修正前にデータが削除されている場合の対応）
  public int modify(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
      DBDataSource dbDataSource) throws PASMException {
    // #else
    // public int modify(ProjNumBean projNumBean, List<Long> deleteAttachFileIDList,
    // DBDataSource dbDataSource) {
    // #endif
    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    int nRet = -1;
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        nRet = modifyWithoutJTA(projNumBean, deleteAttachFileIDList, dbDataSource);
      } else {
        nRet = modifyWithJTA(projNumBean, deleteAttachFileIDList, dbDataSource);
      }
    }
    return nRet;
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // return modifyWithoutJTA(projNumBean, deleteAttachFileIDList, dbDataSource);
    // }
    // return modifyWithJTA(projNumBean, deleteAttachFileIDList, dbDataSource);
    // #endif
  }

  /**
   * P番変更処理
   * 
   * @param iData プロジェクト番号データ（P番ID、分類名、プロジェクト名、売上先、 エンドユーザー、営業担当、営業状態、発行日、開発開始日、開発終了日、
   *        受注日、売上日、入金日、開発費、受注金額、備考、リーダー、メンバー、 更新者、添付ファイル（新規追加分のみ）、通知ユーザー、工数単価、プロジェクト終了フラグのみ使用）
   * @param deleteAttachFileIDList 削除する添付ファイルのIDリスト
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // ※projNumBean 内の添付ファイル設定は、更新で新規に追加される分のみ設定される
  // よって、更新で削除になる分は、projNumBean 以外の別データ（List<long>）で渡す
  // 通知ユーザーは、既存の通知ユーザーを全て削除し、projNumBean 内の内容を新規に追加する
  // #if 1 new （修正前にデータが削除されている場合の対応）
  public int modify(IData iData, List<Long> deleteAttachFileIDList, DBDataSource dbDataSource)
      throws PASMException {
    // #else
    // public int modify(IData iData, List<Long> deleteAttachFileIDList, DBDataSource dbDataSource)
    // {
    // #endif
    // TODO 自動生成されたメソッド・スタブ
    assert (null != iData);

    if (null == iData) {
      throw new IllegalArgumentException();
    }
    if (BeanDataType.PROJ_NUM_DATA != iData.getDataType()) {
      throw new IllegalArgumentException();
    }
    ProjNumBean projNumBean = null;
    if (iData instanceof ProjNumBean) {
      projNumBean = (ProjNumBean) iData;
    } else {
      assert (false);
      throw new IllegalStateException();
    }

    return modify(projNumBean, deleteAttachFileIDList, dbDataSource);
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#modify(jp.co.lsij.p16590004.e_77.model.IData,
   * jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  public int modify(IData iData, DBDataSource dbDataSource) throws PASMException {
    // TODO 自動生成されたメソッド・スタブ
    throw new UnsupportedOperationException("未サポート");
    // return 0;
  }

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#modify_2(jp.co.lsij.p16590004.e_77.model.IData,
   * jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  public int modify_2(IData iData, DBDataSource dbDataSource) throws PASMException {
    // TODO 自動生成されたメソッド・スタブ
    throw new UnsupportedOperationException("未サポート");
    // return 0;
  }

  // ---ここから Phase 2 追加分---
  /**
   * 指定P番の仕入れ総額変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番、仕入れ総額のみ使用）
   * @param isNew 新仕入れ総額フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  public int modifyPurchaseAmount(ProjNumBean projNumBean, boolean isNew, DBDataSource dbDataSource)
      throws PASMException {
    // #else
    // public int modifyPurchaseAmount(ProjNumBean projNumBean, boolean isNew,
    // DBDataSource dbDataSource) {
    // #endif
    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    int nRet = -1;
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        nRet = modifyPurchaseAmountWithoutJTA(projNumBean, isNew, dbDataSource);
      } else {
        nRet = modifyPurchaseAmountWithJTA(projNumBean, isNew, dbDataSource);
      }
    }
    return nRet;
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // return modifyPurchaseAmountWithoutJTA(projNumBean, isNew, dbDataSource);
    // }
    // return modifyPurchaseAmountWithJTA(projNumBean, isNew, dbDataSource);
    // #endif
  }

  /**
   * 指定P番の仕入れ総額変更処理
   * 
   * @param iData プロジェクト番号データ（P番、仕入れ総額のみ使用）
   * @param isNew 新仕入れ総額フラグ
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  public int modifyPurchaseAmount(IData iData, boolean isNew, DBDataSource dbDataSource)
      throws PASMException {
    // #else
    // public int modifyPurchaseAmount(IData iData, boolean isNew, DBDataSource dbDataSource)
    // {
    // #endif
    // TODO 自動生成されたメソッド・スタブ
    assert (null != iData);

    if (null == iData) {
      throw new IllegalArgumentException();
    }
    if (BeanDataType.PROJ_NUM_DATA != iData.getDataType()) {
      throw new IllegalArgumentException();
    }
    ProjNumBean projNumBean = null;
    if (iData instanceof ProjNumBean) {
      projNumBean = (ProjNumBean) iData;
    } else {
      assert (false);
      throw new IllegalStateException();
    }

    return modifyPurchaseAmount(projNumBean, isNew, dbDataSource);
  }

  /**
   * 指定P番の総作業時間変更処理
   * 
   * @param projNumBean プロジェクト番号データ（P番ID、総作業時間のみ使用）
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  public int modifyWorkingTime(ProjNumBean projNumBean, DBDataSource dbDataSource)
      throws PASMException {
    // #else
    // public int modifyWorkingTime(ProjNumBean projNumBean,
    // DBDataSource dbDataSource) {
    // #endif
    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    int nRet = -1;
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        nRet = modifyWorkingTimeWithoutJTA(projNumBean, dbDataSource);
      } else {
        nRet = modifyWorkingTimeWithJTA(projNumBean, dbDataSource);
      }
    }
    return nRet;
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // return modifyWorkingTimeWithoutJTA(projNumBean, dbDataSource);
    // }
    // return modifyWorkingTimeWithJTA(projNumBean, dbDataSource);
    // #endif
  }

  /**
   * 指定P番の総作業時間変更処理
   * 
   * @param iData プロジェクト番号データ（P番ID、総作業時間のみ使用）
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // #if 1 new （修正前にデータが削除されている場合の対応）
  public int modifyWorkingTime(IData iData, DBDataSource dbDataSource) throws PASMException {
    // #else
    // public int modifyWorkingTime(IData iData, DBDataSource dbDataSource)
    // {
    // #endif
    // TODO 自動生成されたメソッド・スタブ
    assert (null != iData);

    if (null == iData) {
      throw new IllegalArgumentException();
    }
    if (BeanDataType.PROJ_NUM_DATA != iData.getDataType()) {
      throw new IllegalArgumentException();
    }
    ProjNumBean projNumBean = null;
    if (iData instanceof ProjNumBean) {
      projNumBean = (ProjNumBean) iData;
    } else {
      assert (false);
      throw new IllegalStateException();
    }

    return modifyWorkingTime(projNumBean, dbDataSource);
  }
  // ---ここまで Phase 2 追加分---

  // ---ここから Phase 2 追加分---
  /**
   * 削除処理
   * 
   * @param lID 削除するID
   * @param dbDataSource DBデータソースオブジェクト
   * @return (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   */
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  public int deleteWithChecking(long lID, DBDataSource dbDataSource) throws PASMException {
    // TODO 自動生成されたメソッド・スタブ
    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    int nRet = -1;
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        nRet = deleteWithoutJTA(lID, dbDataSource);
      } else {
        nRet = deleteWithJTA(lID, dbDataSource);
      }
    }
    return nRet;
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // return deleteWithoutJTA(lID, dbDataSource);
    // }
    // return deleteWithJTA(lID, dbDataSource);
    // #endif
  }
  // ---ここまで Phase 2 追加分---

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#delete(long,
   * jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  public int delete(long lID, DBDataSource dbDataSource) {
    // TODO 自動生成されたメソッド・スタブ
    // #if 1//Phase 2
    throw new UnsupportedOperationException("未サポート");
    // #else//Phase 1
    // // #if 1//new 同期処理追加
    // if (null == ProjNumAndSalesLock.lock) {
    // throw new IllegalStateException();
    // }
    // int nRet = -1;
    // synchronized (ProjNumAndSalesLock.lock) {
    // if (false == Constants.USE_JTA_MODE) {
    // nRet = deleteWithoutJTA(lID, dbDataSource);
    // } else {
    // nRet = deleteWithJTA(lID, dbDataSource);
    // }
    // }
    // return nRet;
    // // #else//org
    // // if (false == Constants.USE_JTA_MODE) {
    // // return deleteWithoutJTA(lID, dbDataSource);
    // // }
    // // return deleteWithJTA(lID, dbDataSource);
    // // #endif
    // #endif
  }

  // ---ここから Phase 2 追加分---
  /**
   * 指定の ID 群の削除
   * 
   * @param lIDs 削除する ID 配列
   * @param dbDataSource DBデータソースオブジェクト
   * @return 配列 (1) SQL データ操作言語 (DML) 文の場合は行数、(2) 何も返さない SQL 文の場合は 0
   * @throws PASMException ビジネスロジック例外
   * @see 処理は all or nothing
   */
  // ※ Phase 2：総作業時間、または、仕入れ総額が設定されている（0 より大きい）場合、削除出来ないもの（例外）とする
  public int[] deleteWithChecking(long[] lIDs, DBDataSource dbDataSource) throws PASMException {
    // TODO 自動生成されたメソッド・スタブ
    // #if 1//new 同期処理追加
    if (null == ProjNumAndSalesLock.lock) {
      throw new IllegalStateException();
    }
    int[] arryRet = null;
    synchronized (ProjNumAndSalesLock.lock) {
      if (false == Constants.USE_JTA_MODE) {
        arryRet = deleteWithoutJTA(lIDs, dbDataSource);
      } else {
        arryRet = deleteWithJTA(lIDs, dbDataSource);
      }
    }
    return arryRet;
    // #else//org
    // if (false == Constants.USE_JTA_MODE) {
    // return deleteWithoutJTA(lIDs, dbDataSource);
    // }
    // return deleteWithJTA(lIDs, dbDataSource);
    // #endif
  }
  // ---ここまで Phase 2 追加分---

  /*
   * (非 Javadoc)
   * 
   * @see jp.co.lsij.p16590004.e_77.model.IFacade#delete(long[],
   * jp.co.lsij.p16590004.common.DBDataSource)
   */
  @Override
  public int[] delete(long[] lIDs, DBDataSource dbDataSource) {
    // TODO 自動生成されたメソッド・スタブ
    // #if 1//Phase 2
    throw new UnsupportedOperationException("未サポート");
    // #else//Phase 1
    // // #if 1//new 同期処理追加
    // if (null == ProjNumAndSalesLock.lock) {
    // throw new IllegalStateException();
    // }
    // int[] arryRet = null;
    // synchronized (ProjNumAndSalesLock.lock) {
    // if (false == Constants.USE_JTA_MODE) {
    // arryRet = deleteWithoutJTA(lIDs, dbDataSource);
    // } else {
    // arryRet = deleteWithJTA(lIDs, dbDataSource);
    // }
    // }
    // return arryRet;
    // // #else//org
    // // if (false == Constants.USE_JTA_MODE) {
    // // return deleteWithoutJTA(lIDs, dbDataSource);
    // // }
    // // return deleteWithJTA(lIDs, dbDataSource);
    // // #endif
    // #endif
  }

}
